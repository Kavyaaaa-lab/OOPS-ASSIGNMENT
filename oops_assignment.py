# -*- coding: utf-8 -*-
"""OOPS Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUjKsA8xEEbIB3jXf4yFwoXk3wWsFIh9

Ans 1 -Object-Oriented Programming (OOP) is a programming paradigm based on the concept of “objects,” which are instances of classes. OOP helps structure code so that it is reusable, modular, and easier to maintain by organizing data and behavior into objects.

Ans 2 - A class is a blueprint for creating objects. It defines a set of attributes and methods that the created objects (instances) will have.

Ans 3 - An object is an instance of a class. It contains real values instead of the placeholders defined in the class.

Ans 4 -
Abstraction	- Hiding unnecessary details and showing only essential features.
Encapsulation - Bundling data and methods into a class and restricting direct access to data.

Ans 5 - Dunder methods (short for “double underscore”) are special methods in Python that begin and end with double underscores. They are used to define behavior for built-in operations (also called "magic methods").

Ans 6 - Inheritance allows one class (child/subclass) to inherit the properties and methods of another class (parent/superclass). It promotes code reusability.

Ans 7 -  Polymorphism allows different classes to have methods with the same name but different implementations.

Ans 8 - Encapsulation is achieved by:

Defining private attributes/methods using a double underscore __.

Providing public methods (getters/setters) to access or modify private data.

Ans 9 - A constructor is a special method called __init__() that is automatically called when an object is created. It initializes the object's attributes.

Ans 10 - Class method: Uses classmethod decorator and takes cls as its first parameter. It can access class-level data.

Static method: Uses staticmethod decorator and does not take self or cls. It behaves like a regular function within a class.

Ans 11 - Method overloading means defining multiple methods with the same name but different parameters.

Python does not support true method overloading. The latest definition of the method overrides the previous one

Ans 12 - The property decorator is used to define getter methods that can be accessed like attributes.

Ans 13 - Occurs when a child class defines a method with the same name as in the parent class.

The child’s method overrides the parent’s method.

Ans 14 - Polymorphism allows objects of different classes to be treated as if they are objects of a common superclass, especially useful when using shared interfaces.

Ans 15 - An abstract class is a class that cannot be instantiated and often contains abstract methods (methods without implementation).

Ans 16 - Modularity: Code is organized into classes/objects

Reusability: Inheritance allows code reuse

Maintainability: Encapsulation makes code easier to manage

Flexibility: Polymorphism allows interchangeable use of different classes

Scalability: Easier to extend with new features

Ans 17 - N/A

Ans 18 - Multiple inheritance means a class can inherit from more than one parent class

Ans 19 - __str__() → Returns a readable string representation of an object (used with print()).

__repr__() → Returns a more formal or unambiguous representation, useful for debugging.

Ans 20 - super() is used to call methods from the parent class inside a child class. It's commonly used in constructors to avoid re-writing code.

Ans 21 - The __del__() method is a destructor in Python. It's called automatically when an object is about to be destroyed, typically when it goes out of scope or the program ends.

Purpose:

Clean up resources (e.g., close files or database connections).

Perform final actions before the object is removed from memory.

Ans 22 - N/A

Ans 23 - Polymorphism allows methods with the same name to behave differently based on the object calling them.

With inheritance, this is done by overriding methods in child classes.

Ans 24 - Method chaining allows calling multiple methods sequentially on the same object in a single line.

Ans 25 - The __call__() method allows an object to be called like a function.

PRACTICAL QUESTIONS

ANSWER 1
"""

class Animal:
    def speak(self):
        print("The animal makes a sound.")
a = Animal()
a.speak()
class Dog(Animal):
    def speak(self):
        print("Bark!")
d= Dog()
d.speak()

"""ANSWER 2"""

from abc import ABC, abstractmethod

class Shape(ABC):
    def area(self):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2
c = Circle(5)
print("Circle area:", c.area())
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height
r = Rectangle(4, 6)
print("Rectangle area:", r.area())

"""ANSWER 3"""

class Vehicle:
    def __init__(self, type):
        self.type = type
class Car(Vehicle):
    def __init__(self, type, brand):
        super().__init__(type)
        self.brand = brand
class ElectricCar(Car):
    def __init__(self, type, brand, battery):
        super().__init__(type, brand)
        self.battery = battery
ecar = ElectricCar("Electric", "Tesla", "100 kWh")
print("Type:", ecar.type)
print("Brand:", ecar.brand)
print("Battery:", ecar.battery)

"""ANSWER 4"""

class Bird:
    def fly(self):
        print("Some birds can fly.")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies high!")
class Penguin(Bird):
    def fly(self):
        print("Penguins can't fly.")

def bird_fly(bird):
    bird.fly()
b1 = Sparrow()
b2 = Penguin()

bird_fly(b1)
bird_fly(b2)

"""ANSWER 5"""

class BankAccount:
    def __init__(self):
        self.__balance = 0  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
        else:
            print("Insufficient balance.")

    def get_balance(self):
        return self.__balance
account = BankAccount()
account.deposit(1000)
account.withdraw(300)
print("Balance:", account.get_balance())

"""ANSWER 6"""

class Instrument:
    def play(self):
        print("Playing an instrument.")

class Guitar(Instrument):
    def play(self):
        print("Strumming the guitar.")

class Piano(Instrument):
    def play(self):
        print("Playing the piano.")

def perform(instrument):
    instrument.play()

perform(Guitar())
perform(Piano())

"""ANSWER 7"""

class MathOperations:
    def add_numbers(cls, a, b):
        return a + b


    def subtract_numbers(a, b):
        return a - b

print("Addition:", MathOperations.add_numbers(10, 5))
print("Subtraction:", MathOperations.subtract_numbers(10, 5))

"""ANSWER 8"""

class Person:
    count = 0

    def __init__(self, name):
        self.name = name
        Person.count += 1


    def get_count(cls):
        return cls.count


p1 = Person("Alice")
p2 = Person("Bob")
print("Total persons:", Person.get_count())

"""ANSWER 9"""

class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

f = Fraction(3, 4)
print(f)

"""ANSWER 10"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"
v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2
print("Vector sum:", v3)

"""ANSWER 11"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

p = Person("Kavya", 19)
p.greet()

"""ANSWER 12"""

class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades

    def average_grade(self):
        return sum(self.grades) / len(self.grades)

s = Student("Emma", [85, 90, 78])
print("Average grade:", s.average_grade())

"""ANSWER 13"""

class Rectangle:
    def set_dimensions(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height


r = Rectangle()
r.set_dimensions(4, 5)
print("Area:", r.area())

"""ANSWER 14"""

class Employee:
    def __init__(self, hours_worked, hourly_rate):
        self.hours_worked = hours_worked
        self.hourly_rate = hourly_rate

    def calculate_salary(self):
        return self.hours_worked * self.hourly_rate

class Manager(Employee):
    def __init__(self, hours_worked, hourly_rate, bonus):
        super().__init__(hours_worked, hourly_rate)
        self.bonus = bonus

    def calculate_salary(self):
        base_salary = super().calculate_salary()
        return base_salary + self.bonus

e = Employee(40, 25)
print("Employee Salary:", e.calculate_salary())

m = Manager(40, 30, 500)
print("Manager Salary:", m.calculate_salary())

"""ANSWER 15"""

class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total_price(self):
        return self.price * self.quantity

p = Product("Laptop", 800, 2)
print("Total Price:", p.total_price())

"""ANSWER 16"""

from abc import ABC, abstractmethod

class Animal(ABC):

    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        return "Moo"

class Sheep(Animal):
    def sound(self):
        return "Baa"


cow = Cow()
sheep = Sheep()
print("Cow says:", cow.sound())
print("Sheep says:", sheep.sound())

"""ANSWER 17"""

class Book:
    def __init__(self, title, author, year_published):
        self.title = title
        self.author = author
        self.year_published = year_published

    def get_book_info(self):
        return f"'{self.title}' by {self.author}, published in {self.year_published}"


b = Book("1984", "George Orwell", 1949)
print(b.get_book_info())

"""ANSWER 18"""

class House:
    def __init__(self, address, price):
        self.address = address
        self.price = price

class Mansion(House):
    def __init__(self, address, price, number_of_rooms):
        super().__init__(address, price)
        self.number_of_rooms = number_of_rooms


m = Mansion("123 Luxury Lane", 2000000, 10)
print("Address:", m.address)
print("Price:", m.price)
print("Rooms:", m.number_of_rooms)